#!/bin/bash

# =================================================================
#            Website Availability Monitor v3
#             (Automated & Robust)
# =================================================================

# --- Configuration & Setup ---
# Change to the script's directory to ensure relative paths work
cd "$(dirname "$0")"

CONFIG_FILE="websites.conf"
LOG_FILE="logs/monitor.log"
ENV_FILE=".env"
STATE_FILE="status/status.log"
LOCK_FILE="/tmp/monitor.lock" # NEW: Lock file to prevent overlaps

# --- Load Environment Variables with Defaults ---
if [ -f "${ENV_FILE}" ]; then
    export $(grep -v '^#' ${ENV_FILE} | xargs)
fi

# Use default values if not set in .env
MAX_RETRIES=${MAX_RETRIES:-3}
RETRY_DELAY=${RETRY_DELAY:-5}
ALERT_METHOD=${ALERT_METHOD:-log}

# --- Lock File and Dependency Check ---

# NEW: Function to check for required commands
check_dependencies() {
    local missing=0
    for cmd in curl mail; do
        if ! command -v "$cmd" &> /dev/null; then
            echo "Error: Required command '$cmd' is not installed."
            missing=1
        fi
    done
    [ $missing -eq 1 ] && exit 1
}

# NEW: Exit if script is already running
if [ -f "${LOCK_FILE}" ]; then
    # Check if the process is actually still running
    pid=$(cat "${LOCK_FILE}")
    if ps -p $pid > /dev/null; then
        echo "Monitor script is already running with PID: ${pid}. Exiting."
        exit 1
    else
        # The process is not running, but lock file was left behind.
        echo "Warning: Stale lock file found. Removing it."
        rm -f "${LOCK_FILE}"
    fi
fi

# NEW: Create lock file and register a trap to clean it up on exit
echo $$ > "${LOCK_FILE}"
trap 'rm -f "${LOCK_FILE}"; echo "Script finished, lock file removed."' EXIT TERM INT

# --- Functions (The rest of the script is largely the same) ---

log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "${LOG_FILE}"
}

send_email_alert() {
    local url=$1
    local reason=$2
    local subject=$3
    local body="Website: ${url}
Reason: ${reason}
Timestamp: $(date '+%Y-%m-%d %H:%M:%S')
"
    echo "${body}" | mail -s "${subject}" "${EMAIL_TO}"
    log "ALERT: Email alert with subject '${subject}' sent to ${EMAIL_TO} for ${url}."
}

send_alert() {
    local url=$1
    local reason=$2
    local status=$3

    local subject=""
    if [ "$status" == "DOWN" ]; then
        subject="⚠️ Website Down Alert: ${url}"
    elif [ "$status" == "RECOVERY" ]; then
        subject="✅ Website Recovered: ${url}"
    else
        return
    fi

    case "${ALERT_METHOD}" in
        "email")
            send_email_alert "$url" "$reason" "$subject"
            ;;
        "log")
            log "ALERT_TRIGGERED (method=log): Status is ${status} for ${url}. Reason: ${reason}"
            ;;
        *)
            log "WARNING: Unknown ALERT_METHOD '${ALERT_METHOD}'. Defaulting to log."
            log "ALERT_TRIGGERED (method=log): Status is ${status} for ${url}. Reason: ${reason}"
            ;;
    esac
}

get_last_status() {
    local url=$1
    if [ ! -f "${STATE_FILE}" ]; then
        echo "UP"
        return
    fi
    grep "^${url}=" "${STATE_FILE}" | cut -d'=' -f2
}

update_status() {
    local url=$1
    local status=$2
    local temp_state_file
    temp_state_file=$(mktemp)

    if [ -f "${STATE_FILE}" ]; then
        grep -v "^${url}=" "${STATE_FILE}" > "${temp_state_file}"
    fi
    
    echo "${url}=${status}" >> "${temp_state_file}"
    mv "${temp_state_file}" "${STATE_FILE}"
}

check_site() {
    local url=$1
    local current_status="UP"
    local reason=""

    for (( i=1; i<=MAX_RETRIES; i++ )); do
        http_code=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 --max-time 10 "${url}")
        curl_exit_code=$?

        if [ $curl_exit_code -ne 0 ]; then
            current_status="DOWN"
            reason="Connection Error. cURL exit code: ${curl_exit_code}."
        elif [ "${http_code}" -ge 200 ] && [ "${http_code}" -lt 400 ]; then
            current_status="UP"
            reason="HTTP Status Code: ${http_code}."
            break
        else
            current_status="DOWN"
            reason="HTTP Status Code: ${http_code}."
        fi

        if [ "$current_status" == "DOWN" ] && [ $i -lt $MAX_RETRIES ]; then
            log "INFO: Check for ${url} failed (Attempt ${i}/${MAX_RETRIES}). Retrying in ${RETRY_DELAY}s..."
            sleep ${RETRY_DELAY}
        fi
    done

    last_status=$(get_last_status "${url}")
    last_status=${last_status:-"UP"} 

    log "Site: ${url} | Current Status: ${current_status} | Last Known Status: ${last_status}"

    if [ "${current_status}" == "DOWN" ] && [ "${last_status}" == "UP" ]; then
        log "STATE_CHANGE: ${url} has gone DOWN. Reason: ${reason}"
        send_alert "${url}" "${reason}" "DOWN"
        update_status "${url}" "DOWN"
    elif [ "${current_status}" == "UP" ] && [ "${last_status}" == "DOWN" ]; then
        log "STATE_CHANGE: ${url} has RECOVERED. Reason: ${reason}"
        send_alert "${url}" "${reason}" "RECOVERY"
        update_status "${url}" "UP"
    elif [ "${current_status}" != "${last_status}" ]; then
        update_status "${url}" "${current_status}"
    fi
}

# --- Main Script Logic ---

check_dependencies # NEW: Run dependency check first

mkdir -p "$(dirname "${LOG_FILE}")"
mkdir -p "$(dirname "${STATE_FILE}")"

if [ ! -f "${CONFIG_FILE}" ]; then
    log "Error: Configuration file not found at ${CONFIG_FILE}"
    exit 1
fi

log "--- Monitor script started ---"

while IFS= read -r site || [[ -n "$site" ]]; do
    if [[ -n "$site" && ! "$site" =~ ^# ]]; then # Also ignore commented lines
        check_site "$site"
    fi
done < "${CONFIG_FILE}"

log "--- Monitor script finished ---"
